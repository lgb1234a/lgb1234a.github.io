<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> CoreMotion计算设备yaw方向的旋转角度 · Chenyn</title><meta name="description" content="CoreMotion计算设备yaw方向的旋转角度 - chenynle@gmail.com"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Chenyn"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.jpeg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/1780200685" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/lgb1234a" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">CoreMotion计算设备yaw方向的旋转角度</h1><div class="post-info">Apr 1, 2018</div><div class="post-content"><blockquote>
<p>先说说公司需求吧，这个需求里面有一个部分要做一个雷达，这个雷达要监听我的设备沿y轴旋转<strong>（为啥是y轴下面会提到）</strong>的倾角，然后根据这个倾角，雷达可以判断当前位置的物体是否在我的镜头范围内。</p>
</blockquote>
<a id="more"></a>
<h2 id="先挖一个坑"><a href="#先挖一个坑" class="headerlink" title="先挖一个坑"></a>先挖一个坑</h2><p>关于陀螺仪的创建和用法我这里按下不提，因为遇到这个问题的小伙伴对于获取<code>CMDeviceMotion</code>对象应该没什么问题。（<strong>啥，你说有？那就出门百度陀螺仪用法或者参考我后面给出的<a href="https://github.com/lgb1234a/TNMapARDemo" target="_blank" rel="noopener">demo</a></strong>）</p>
<p><strong>下面是第一个需要注意的地方：</strong>系统提供的<code>block</code>是在一个异步线程，所以如果需要做UI操作，请回到主线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Push方式获取和处理数据</span><br><span class="line">__weak typeof(self) weafSelf = self;</span><br><span class="line">[self.motionManager startDeviceMotionUpdatesToQueue:queue withHandler:^(CMDeviceMotion * _Nullable motion, NSError * _Nullable error) &#123;</span><br><span class="line">    // 首先这里是在一个异步线程，要刷新UI操作的话，需要回到主线程。</span><br><span class="line">    [weafSelf updateRadarStatuWithDeviceMotion:motion];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>现在，拿到了我们要的<code>CMDeviceMotion</code>对象，要获取旋转角度，自然要找到我们需要的那个参数，先请看下图（<a href="http://blog.denivip.ru/index.php/2013/07/the-art-of-core-motion-in-ios/?lang=en" target="_blank" rel="noopener">图片来源，有精力的同学可以看看这篇文章，里面非常系统的解释了CoreMotion里面一些现象的成因，有些坑我也是在这里找到解决方案的</a>）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1445324-61b222ffc7193549.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="CoreMotionRotationAxes.png"></p>
<p>现在知道了我们需要获取y轴旋转角度的原因<strong>（x轴，z轴同理，就没必要一一介绍了）</strong>，我把关于设备当前放置状态的代码直接挑出来了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//4 代码来自上面我希望大家去看的那篇文章</span><br><span class="line">CMAttitude *attitude = self.motionManager.deviceMotion.attitude;</span><br><span class="line">self.pitch.text = [NSString stringWithFormat:@&quot;%.3f&quot;, attitude.pitch];</span><br><span class="line">self.roll.text = [NSString stringWithFormat:@&quot;%.3f&quot;, attitude.roll];</span><br><span class="line">self.yaw.text = [NSString stringWithFormat:@&quot;%.3f&quot;, attitude.yaw];</span><br></pre></td></tr></table></figure>
<p>其中<code>yaw</code>就是设备绕y轴的偏转角度，当时满心欢喜拿这个数据去旋转雷达中的镜头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// yaw角度为零的时候，就是出生点位置（注意这一块代码需要放在主线程中操作，参考[demo](https://github.com/lgb1234a/TNMapARDemo)）</span><br><span class="line">self.radarBackImgView.layer.anchorPoint = CGPointMake(0.5, 0.5);</span><br><span class="line">self.radarBackImgView.transform = CGAffineTransformMakeRotation(yaw);</span><br></pre></td></tr></table></figure>
<p>这样做，乍一看确实实现了我的需求，雷达中显示的镜头确实和我设备旋转是同步的，<strong>但是呢，看下面动图：</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1445324-4005cd4b9a18b617.gif?imageMogr2/auto-orient/strip" alt="大辉哥强势出镜😂.gif"></p>
<p><strong>我现在将设备上下旋转，注意看右上角的雷达，居然也会出现旋转的情况，这说明yaw这个值会被roll和pitch影响，原文说明：</strong></p>
<p><code>At the first glance, nothing is complex here. All the angles duly change their value at device rotation. However, if we look closer, we can see that yaw can sometimes flip by somewhat 180 degrees at other angles’ change. So it means that changes in roll and pitch can affect yaw.</code></p>
<p><code>This post provides details of the issue called gimbal lock, along with its effect on Euler angles. The author also has mentioned the 180 degrees flip which you surely would like to avoid if animation of any on-screen objects depends on yaw.</code></p>
<p>对，你遇到了著名的<strong>万向节死锁问题</strong>，惊不惊喜，意不意外？所以作者特意告知大家，<strong>不要依赖yaw这个属性去做任何屏幕上控件的动画。</strong></p>
<p>好了，坑貌似已经说得很明确了，如果还觉得云里雾里的，强烈建议去看我上面说的那篇<a href="http://blog.denivip.ru/index.php/2013/07/the-art-of-core-motion-in-ios/?lang=en" target="_blank" rel="noopener">原文</a>，作者说的非常详细！！</p>
<h2 id="那我们该怎么办呢？？"><a href="#那我们该怎么办呢？？" class="headerlink" title="那我们该怎么办呢？？"></a>那我们该怎么办呢？？</h2><p>再来看看那篇文章里面还说了什么（膜拜作者大大）：</p>
<p><code>The post also mentions that a common way to avoid gimbal lock is to avoid Euler angles in favor of other ways of describing spacial orientation. Particularly, you can use quaternions.</code></p>
<p><strong>作者说，为了避免万向节死锁问题</strong>（说术语的感觉好爽啊，以后可以出去吹比了：你知道啥叫万向节死锁吗？咳~正经点！）<strong>，就不要用这个系统直接返回给你的欧拉角度</strong>（哎，太廉价的东西就是不好用），<strong>那我们用啥啊？贴心的作者说了，你可以用<code>quaternions</code></strong>（这玩意逼格更高，不信你去维基百科搜<code>四元数</code>，鉴于我现在没空深挖理论，<em>也挖不动</em>😂）。</p>
<p>现在知道了要用<strong>四元数</strong>去做，可是作者你没说完啊，我只知道要用它，但是还无从下手~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1445324-8fb8b6402c01223e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="CMAttitude的属性.png"></p>
<p>最后只能求助于万能的gg：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1445324-a182333fe5098540.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="搜索项.png"></p>
<p>嗯，结果有非常多，看来踩坑的人不少，各路算法简直琳琅满目，我就不给大家一一甄别了，直接上我找到的最满意的算法，完美解决了我现在遇到的问题，<a href="https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles" target="_blank" rel="noopener">维基百科-《Conversion between quaternions and Euler angles》</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void toEulerianAngle(const Quaterniond&amp; q, double&amp; roll, double&amp; pitch, double&amp; yaw)</span><br><span class="line">&#123;</span><br><span class="line">double ysqr = q.y() * q.y();</span><br><span class="line"></span><br><span class="line">// roll (x-axis rotation)</span><br><span class="line">double t0 = +2.0 * (q.w() * q.x() + q.y() * q.z());</span><br><span class="line">double t1 = +1.0 - 2.0 * (q.x() * q.x() + ysqr);</span><br><span class="line">roll = std::atan2(t0, t1);</span><br><span class="line"></span><br><span class="line">// pitch (y-axis rotation)</span><br><span class="line">double t2 = +2.0 * (q.w() * q.y() - q.z() * q.x());</span><br><span class="line">t2 = ((t2 &gt; 1.0) ? 1.0 : t2);</span><br><span class="line">t2 = ((t2 &lt; -1.0) ? -1.0 : t2);</span><br><span class="line">pitch = std::asin(t2);</span><br><span class="line"></span><br><span class="line">// yaw (z-axis rotation)</span><br><span class="line">double t3 = +2.0 * (q.w() * q.z() + q.x() * q.y());</span><br><span class="line">double t4 = +1.0 - 2.0 * (ysqr + q.z() * q.z());</span><br><span class="line">yaw = std::atan2(t3, t4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，这是个C++的算法（废话！），然后各位可以按照自己的需求，套用一下，至少对我的业务来说，是完全OK的~</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/04/01/Xcode-8在iOS9-3之前的设备（真机或模拟器）上调试，频繁crash，crash位置随机，且无崩溃原因 /" class="prev">prev_post</a><a href="/2018/04/01/swift密文输入UITextfield内存问题/" class="next">next_post</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'chenyn';
var disqus_identifier = '2018/04/01/CoreMotion/';
var disqus_title = 'CoreMotion计算设备yaw方向的旋转角度';
var disqus_url = 'http://yoursite.com/2018/04/01/CoreMotion/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//chenyn.disqus.com/count.js" async></script><div class="copyright"><p>© 2018 <a href="http://yoursite.com">chenynle@gmail.com</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chenyn</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-16T05:13:25.566Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chenynle@gmail.com</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter iOS实战随笔</title>
    <link href="http://yoursite.com/2019/09/16/Flutter%20iOS%E5%AE%9E%E6%88%98%E9%9A%8F%E7%AC%94/"/>
    <id>http://yoursite.com/2019/09/16/Flutter iOS实战随笔/</id>
    <published>2019-09-15T16:00:00.000Z</published>
    <updated>2019-09-16T05:13:25.566Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote><p>回到南昌半年，五味杂陈。本来项目代码就这种混乱，加之各种原因下（之前的开发人员通过隐藏支付入口来绕开应用审核，因为一次审核被拒后，由于技术的英文水平不行，没按照苹果提供的解决思路而是采用了歪门邪道，我也是醉了），应用被封1年，账号主体被冻结。所以在保证现有开发新需求的前提下，重写重构整个项目再重新上架成了重中之重。在讨论过swift还是flutter之后，我决定采用flutter，毕竟公司还有闲置的安卓开发人员，希望借助他们可以快速完成一些flutter端开发，iOS开发人员可以专注native和IM开发。</p><p>在利用闲暇时间调研和学习之后，打算记录一下这段时间遇到的主要几个问题，以随笔的形式记录下来。</p><a id="more"></a><h1 id="quote"><a href="#quote" class="headerlink" title="quote"></a>quote</h1><p>基于云信IM实现的类微信IM聊天框架（iOS可运行，Android暂未实现）</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">app/</span><br><span class="line">|---- android  #暂无</span><br><span class="line">|---- images   #flutter侧 图片文件目录</span><br><span class="line">|---- ios      #ios 工作区</span><br><span class="line">Appdelegate   </span><br><span class="line">|---- Runner       #iOS 业务代码区</span><br><span class="line">|---- Contacts    #通讯录（纯flutter UI）</span><br><span class="line">|---- Hybird      #flutter&amp;native交互bridge</span><br><span class="line">|---- Login       #为空，目前登录UI为纯flutter页面</span><br><span class="line">|---- Mine        #我的（纯flutter UI）</span><br><span class="line">|---- Session     #会话（嵌套的云信IM页面）</span><br><span class="line">|---- lib   #flutter 代码</span><br><span class="line">|---- Base # 网络请求、util、hybird bridge</span><br><span class="line">|---- Contacts  # 通讯录UI</span><br><span class="line">|---- Login  #登录页UI</span><br><span class="line">|---- Mine   #我的</span><br><span class="line">|---- Session   #会话页</span><br><span class="line">main.dart  #flutter 入口以及页面路由</span><br><span class="line">|---- nim_sdk_util  #云信SDK服务的插件</span><br><span class="line">|---- wx_sdk    #微信登录、分享的插件</span><br></pre></td></tr></table></figure><h2 id="框架思路（遇到的几个问题）"><a href="#框架思路（遇到的几个问题）" class="headerlink" title="框架思路（遇到的几个问题）"></a>框架思路（遇到的几个问题）</h2><h3 id="如何管理页面堆栈"><a href="#如何管理页面堆栈" class="headerlink" title="如何管理页面堆栈"></a>如何管理页面堆栈</h3><p>在解决这个问题的时候，我走了很多弯路，一开始打算是flutter为主，native为辅（毕竟是从零开始的新项目），然后在管理堆栈的时候遇到很多挑战，这种做法在flutter–push–&gt;flutter很简单，当我要flutter–push–&gt;native或者native–push–&gt;flutter的时候，就蒙圈了。当时找了闲鱼的flutter_boost解决方案，奈何他们的flutter版本还未支持到1.7，集成进来之后各种问题，遂放弃之。</p><p>随后我改变思路，采用以native为骨架，flutter为血肉的方式将我这个剪不断理还乱的工程重构了一遍。先抽出来一个继承自<code>FlutterViewController</code>的基类<code>CJViewController</code>，然后提供一个初始化方法<code>- (instancetype)initWithFlutterOpenUrl:(NSString *)openUrl;</code>，通过<code>FlutterViewController</code>的<code>setInitialRoute</code>方法，这样外界传入一个自定义好的路由url，就可以解析到对应的flutter页面，并且可以由native来进行堆栈管理，当然也可以采用flutter <code>Navigator</code>的转场方式跳转到另一个flutter页面。</p><p><code>flutter</code>侧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map params = &#123;&apos;route&apos;:&apos;setting&apos;,&apos;channel_name&apos;:&apos;com.zqtd.cajian/setting&apos;&#125;;</span><br><span class="line">String pStr = convert.jsonEncode(params);</span><br><span class="line">platform.invokeMethod(&apos;pushViewControllerWithOpenUrl:&apos;, [pStr]);</span><br></pre></td></tr></table></figure></p><p><code>native</code>侧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString *openUrl = @&quot;&#123;\&quot;route\&quot;:\&quot;login_entrance\&quot;,\&quot;channel_name\&quot;:\&quot;com.zqtd.cajian/login_entrance\&quot;&#125;&quot;;</span><br><span class="line">CJViewController *nextVc = [[CJViewController alloc] initWithFlutterOpenUrl:openUrl];</span><br><span class="line">[self.navigationController pushViewController:nextVc</span><br><span class="line">animated:YES];</span><br></pre></td></tr></table></figure></p><h3 id="如何在native让我集成的插件代码也可以发起网络请求，做一些与用户的反馈交互（弹出提示框hub之类的——Base-里面的代码）"><a href="#如何在native让我集成的插件代码也可以发起网络请求，做一些与用户的反馈交互（弹出提示框hub之类的——Base-里面的代码）" class="headerlink" title="如何在native让我集成的插件代码也可以发起网络请求，做一些与用户的反馈交互（弹出提示框hub之类的——Base/里面的代码）"></a>如何在native让我集成的插件代码也可以发起网络请求，做一些与用户的反馈交互（弹出提示框hub之类的——Base/里面的代码）</h3><p>在集成微信登录sdk插件的时候，我并不想只是简单的将微信sdk的方法简单的bridge一遍，然后交给flutter调用。我希望在<code>sendReq</code>的同时，我的插件可以处理回调，并一气呵成的完成微信登录的整套操作，包括调用我的网络请求，进行登录提示。但是我不可能把native主工程的代码再在插件pod bridge代码里面再重写一遍，这样即低效又丑陋。我想到了flutter插件的podspec可以依赖其他的pod代码，于是我尝试把我需要用的常用代码（网络请求，弹窗组件，扩展方法等）封装成私有仓库，然后再在插件的podspec里面添加这个依赖，事实证明这样是可行的，由此我便实现了在微信sdk插件里面完成整套微信登录流程。</p><h3 id="如何进行跨平台通信"><a href="#如何进行跨平台通信" class="headerlink" title="如何进行跨平台通信"></a>如何进行跨平台通信</h3><p>这一块也是我初学时比较头疼的，按照官方的思路，传递根视图控制器的<code>binaryMessenger</code>注册channel，然后在flutter页面完成对应的注册操作就可以建立通信了。在一开始我采用flutter嵌套native的框架思路时，发现当我登录完成，替换我的keywindow的根视图之后，我的通信就中断了。后来我发现每次当你的flutter路由被native切断，你就需要重新注册你的channel，不然你的消息就无法传递下去。而我实现公共bridge方法的目的是，我可以通过它在任何地方进行双端的通信。于是在我完成页面堆栈的管理之后，在我的基类<code>CJViewController</code>初始化方法里，注册这个同名channel，这样不管我是在native页面还是flutter页面，获取到的channel都是同一个。</p><p>当我一个flutter页面需要调用一些native操作时，我可以通过创建<code>CJViewController</code>的子类，在<code>- (instancetype)initWithFlutterOpenUrl:(NSString *)openUrl;</code>的openUrl里面指定我的channelName，然后完成一个独立的私有的通道。</p><p><code>CJViewController.h</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">初始化一个flutter 页面，以FlutterVC为容器</span><br><span class="line"></span><br><span class="line">\\******</span><br><span class="line">需要的JSON字符串格式如下</span><br><span class="line">&#123;</span><br><span class="line">&apos;route&apos;:&apos;login&apos;,</span><br><span class="line">&apos;channel_name&apos;:&apos;com.zqtd.cajian/login&apos;,</span><br><span class="line">&apos;params&apos;:&#123;</span><br><span class="line">&apos;team_id&apos;:&apos;298ssdj9238&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">*******\\</span><br><span class="line">@param openUrl 页面初始化路由和参数</span><br><span class="line"></span><br><span class="line">@return 返回VC</span><br><span class="line">*/</span><br><span class="line">- (instancetype)initWithFlutterOpenUrl:(NSString *)openUrl;</span><br></pre></td></tr></table></figure><p><code>CJViewController.m</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithFlutterOpenUrl:(NSString *)openUrl</span><br><span class="line">&#123;</span><br><span class="line">self = [super initWithProject:nil</span><br><span class="line">nibName:nil</span><br><span class="line">bundle:nil];</span><br><span class="line">if(self) &#123;</span><br><span class="line">[self setInitialRoute:openUrl];</span><br><span class="line">[self registerChannel];</span><br><span class="line"></span><br><span class="line">NSDictionary *params = [NSDictionary cj_dictionary:openUrl];</span><br><span class="line"></span><br><span class="line">// 设置回调</span><br><span class="line">_mc = [FlutterMethodChannel methodChannelWithName:params[@&quot;channel_name&quot;] binaryMessenger:self.engine.binaryMessenger];</span><br><span class="line"></span><br><span class="line">__weak typeof(self) wself = self;</span><br><span class="line">[_mc setMethodCallHandler:^(FlutterMethodCall * _Nonnull call, FlutterResult  _Nonnull result) &#123;</span><br><span class="line">ZZLog(@&quot;flutter call :%@&quot;, call.method);</span><br><span class="line">SEL callMethod = NSSelectorFromString(call.method);</span><br><span class="line">if([wself respondsToSelector:callMethod]) &#123;</span><br><span class="line">[wself performSelector:callMethod</span><br><span class="line">withObject:call.arguments</span><br><span class="line">afterDelay:0];</span><br><span class="line">&#125;else &#123;</span><br><span class="line">ZZLog(@&quot;%@未实现%@&quot;, NSStringFromClass(wself.class), call.method);</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 渲染完成</span><br><span class="line">[self setFlutterViewDidRenderCallback:^&#123;</span><br><span class="line">//            [_mc invokeMethod:@&quot;会在widget build完成之后调用&quot; arguments:nil];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// util </span><br><span class="line">- (void)registerChannel</span><br><span class="line">&#123;</span><br><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line"></span><br><span class="line">_utilChannel = [FlutterMethodChannel</span><br><span class="line">methodChannelWithName:@&quot;com.zqtd.cajian/util&quot;</span><br><span class="line">binaryMessenger:self.engine.binaryMessenger];</span><br><span class="line"></span><br><span class="line">[_utilChannel setMethodCallHandler:^(FlutterMethodCall *call, FlutterResult result) &#123;</span><br><span class="line">SEL callMethod = NSSelectorFromString(call.method);</span><br><span class="line">if([weakSelf respondsToSelector:callMethod])</span><br><span class="line">&#123;</span><br><span class="line">[weakSelf performSelector:callMethod</span><br><span class="line">withObject:call.arguments</span><br><span class="line">afterDelay:0];</span><br><span class="line">&#125;else &#123;</span><br><span class="line">[CJUtilBridge bridgeCall:call result:result];</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">// Do any additional setup after loading the view.</span><br><span class="line">// (@&quot;view did load --- 会在widget build开始之前调用&quot;);</span><br><span class="line">[GeneratedPluginRegistrant registerWithRegistry:self];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从flutter发来的push新页面操作</span><br><span class="line">- (void)pushViewControllerWithOpenUrl:(NSArray *)params</span><br><span class="line">&#123;</span><br><span class="line">NSString *openUrl = params.firstObject;</span><br><span class="line">CJViewController *nextVc = [[CJViewController alloc] initWithFlutterOpenUrl:openUrl];</span><br><span class="line">[self.navigationController pushViewController:nextVc</span><br><span class="line">animated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 推出当前页</span><br><span class="line">- (void)popFlutterViewController</span><br><span class="line">&#123;</span><br><span class="line">[self.navigationController popViewControllerAnimated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">ZZLog(@&quot;%@ - dealloced!&quot;, NSStringFromClass(self.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>flutter侧解析路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Widget _widgetForRoute(String openUrl) &#123;</span><br><span class="line">debugPrint(&apos;FlutterViewController openUrl:&apos; + openUrl);</span><br><span class="line">dynamic initParams = json.decode(openUrl);</span><br><span class="line"></span><br><span class="line">String route = initParams[&apos;route&apos;];</span><br><span class="line">String cn = initParams[&apos;channel_name&apos;];</span><br><span class="line">Map params = initParams[&apos;params&apos;];</span><br><span class="line">switch (route) &#123;</span><br><span class="line">case &apos;login_entrance&apos;:</span><br><span class="line">return new LoginEntrance(channelName: cn);</span><br><span class="line">case &apos;mine&apos;:</span><br><span class="line">return new MineWidget(cn);</span><br><span class="line">case &apos;contacts&apos;:</span><br><span class="line">return new ContactsWidget(params);</span><br><span class="line">case &apos;setting&apos;:</span><br><span class="line">return new SettingWidget(cn);</span><br><span class="line">default:</span><br><span class="line">return MaterialApp(</span><br><span class="line">home: Scaffold(</span><br><span class="line">body: Center(child: Text(&apos;未找到route为: $route 的页面&apos;)),</span><br><span class="line">),</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">runApp(_widgetForRoute(ui.window.defaultRouteName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>demo还不够完善，但是对于目前app重构的思路已经很清晰了，希望下篇可以来一个完整的回顾。<br><a href="https://github.com/lgb1234a/flutter_IM.git" target="_blank" rel="noopener">demo地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;回到南昌半年，五味杂陈。本来项目代码就这种混乱，加之各种原因下（之前的开发人员通过隐藏支付入口来绕开应用审核，因为一次审核被拒后，由于技术的英文水平不行，没按照苹果提供的解决思路而是采用了歪门邪道，我也是醉了），应用被封1年，账号主体被冻结。所以在保证现有开发新需求的前提下，重写重构整个项目再重新上架成了重中之重。在讨论过swift还是flutter之后，我决定采用flutter，毕竟公司还有闲置的安卓开发人员，希望借助他们可以快速完成一些flutter端开发，iOS开发人员可以专注native和IM开发。&lt;/p&gt;
&lt;p&gt;在利用闲暇时间调研和学习之后，打算记录一下这段时间遇到的主要几个问题，以随笔的形式记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="Flutter开发" scheme="http://yoursite.com/categories/Flutter%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS项目拆分后xib导致的崩溃异常</title>
    <link href="http://yoursite.com/2018/05/29/iOS%E9%A1%B9%E7%9B%AE%E6%8B%86%E5%88%86%E5%90%8Exib%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B4%A9%E6%BA%83%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2018/05/29/iOS项目拆分后xib导致的崩溃异常/</id>
    <published>2018-05-29T03:18:44.000Z</published>
    <updated>2018-05-29T09:19:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上个迭代产品提了个需求，说现在的登录注册页面<code>UI</code>设计太丑了，需要换一个“清爽”一点的界面。然后，看了看“前人们”留下的若干年前的代码，顶住架构童鞋禁用<code>xib</code>的要求（因为会增加包体积大小，公司对这一块还是挺敏感的），毅然决定用<code>xib</code>做（毕竟这个需求只估了3天，加上老代码由于之前人交接不善，近乎烂尾，连文档都没了，注释也没有一行，逻辑全靠猜）。</p><p>不紧不慢，把以前的需求理清楚，<code>xib</code>画<code>UI</code>确实爽到，不用再浪费时间去<code>alloc - init</code>了，可以腾出更多的时间在业务上面。</p><p>提完代码，review OK，打包，提测，回归，一切都在掌握之中。（这里要交代一下背景，我们项目之前由于业务扩张的原因，整个工程也臃肿不堪，然后举全App研发之力，把工程按照业务模块给拆分成了一个个私有仓库，这次的登录注册也是独立的一个<code>login</code>仓库）</p><p>然后，我们架构小哥“手贱”拉了<code>login</code>仓库的代码，噩梦就开始了，每每他点击登录，拉起登录页的时候，就会<code>crash</code>。我找到其他组热心的小哥，也拉了一下<code>login</code>的代码，并不会复现（由于我上次要调试一台<code>iOS</code> 11.3的ipX，<code>Xcode</code>更新到了9.3.1，那位热心小哥是<code>Xcode</code> 9.2.1，架构小哥后面也更新到9.3.1），说明我提交进仓库的代码并没有问题。<br>下面是异常信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Terminating app due to uncaught exception &apos;NSUnknownKeyException&apos;, reason: &apos;[&lt;**LoginViewController 0x************&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key **. &apos;</span><br></pre></td></tr></table></figure></p></blockquote><a id="more"></a><blockquote><p>好了，前面扯了那么多故事背景，终于引出来要讲的东西了。看到这，稍微有些<code>xib</code>经验的童鞋应该知道报错原因吧：<strong>不就是xib绑定到VC的属性，关联失败，导致KVC报错嘛</strong>。比较常见的情况就是你修改了<code>.h</code>或<code>.m</code>里面的属性名，但是没有重新关联，就会报这个异常。看到上面背景交代的一大段废话，差不多就可以排除这个原因了。但肯定还是关联出了问题。后面架构童鞋把<code>login</code>仓库放开，进入<code>debug</code>模式，然后点登录的时候，完全OK。这就更验证了我的猜想：<strong>应该是哪里的配置导致在cocoapods的代码在以静态库的形式链接到主工程的时候，xib里面的控件关联到File’s Owner失败</strong><br>gg到有人是因为添加一个自定义<code>view</code>到<code>sb</code>上的<code>view</code>中，会导致同样的现象<br><img src="https://s1.ax1x.com/2018/05/29/C4TjZn.png" alt="stackoverflow"><br>而帮助他解决问题的是这个不起眼的东西<code>Inherit Module From Target</code>：<br><img src="https://s1.ax1x.com/2018/05/29/C4Hn7n.png" alt="stackoverflow"><br>从字面意义上看，好像并不能看出来什么：<strong>从当前Target继承模块？</strong><br>指望从官方文档中获取信息，无果。从<code>Stack Overflow</code>上得到的解释是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">My project has a variety of targets (free, paid, home free, home paid) and I have a class that is only used in the home variants.</span><br><span class="line"></span><br><span class="line">When I just added my class and let it default to Module I kept getting an error at run time that the class was not defined in the storyboard.</span><br><span class="line"></span><br><span class="line">By checking the &quot;Inherited from Target&quot; option the module gets compiled in for the targets I use it in (Target Memberships for swift file and everything works.</span><br><span class="line"></span><br><span class="line">I am assuming this was an optimization so the module would not be included when not needed - but that is just a guess.</span><br><span class="line"></span><br><span class="line">Needless to say this wasted an entire day to figure out - hope it helps some others.</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>他猜想的是：他的项目中有许多<code>Target</code>，勾上这个选项，可以让这个组件在需要时被引入。<br>那么当架构童鞋放开仓库代码<code>debug</code>和没有放开的时候，在链接的时候，有什么不同，会导致<code>xib</code>指定的<code>File&#39;s Owner</code>关联到<code>xib</code>出错呢？换言之，就是在<code>debug</code>的时候<code>File&#39;s Owner</code>是可以被编译器找到的，因为<code>debug</code>的时候，主工程是直接编译链接的仓库源码，但在不开放仓库的时候，添加到主工程的仓库<code>framework</code>会导致<code>xib</code>关联失败。<br>抱着死马当活马医的心态，我让他勾选了这个选项，再把仓库代码收起来，以静态库的形式添加到主工程，点击登录，问题不复现了。<br>由于只有现象，没有文档佐证，只能提出我的猜想：<strong>在放开仓库源码的时候，工程运行正常，这很好理解。在仓库收起来的时候，静态库链接的过程中，存在xib的File’s Owner找不到的情况（原因未知），而这个选项，可以使编译器在链接的时候，找到明确的File’s Owner指定的那个VC的路径，从而保证可以关联到对应的xib上面的控件</strong><br>但是这一切只是猜测，官方对于这个开关只字未提，想到上面那位小哥的吐槽：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unfortunately, due to lack of proper documentation, developing for Apple is like this: 10 seconds to add a feature, 10 hours to make it work.</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>如果有哪位童鞋有自己的见解，或者更明确的解释，欢迎联系<br>mail: <a href="mailto:chenynle@gmail.com" target="_blank" rel="noopener">chenynle@gmail.com</a> ，wx:  lgb1234a</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;上个迭代产品提了个需求，说现在的登录注册页面&lt;code&gt;UI&lt;/code&gt;设计太丑了，需要换一个“清爽”一点的界面。然后，看了看“前人们”留下的若干年前的代码，顶住架构童鞋禁用&lt;code&gt;xib&lt;/code&gt;的要求（因为会增加包体积大小，公司对这一块还是挺敏感的），毅然决定用&lt;code&gt;xib&lt;/code&gt;做（毕竟这个需求只估了3天，加上老代码由于之前人交接不善，近乎烂尾，连文档都没了，注释也没有一行，逻辑全靠猜）。&lt;/p&gt;
&lt;p&gt;不紧不慢，把以前的需求理清楚，&lt;code&gt;xib&lt;/code&gt;画&lt;code&gt;UI&lt;/code&gt;确实爽到，不用再浪费时间去&lt;code&gt;alloc - init&lt;/code&gt;了，可以腾出更多的时间在业务上面。&lt;/p&gt;
&lt;p&gt;提完代码，review OK，打包，提测，回归，一切都在掌握之中。（这里要交代一下背景，我们项目之前由于业务扩张的原因，整个工程也臃肿不堪，然后举全App研发之力，把工程按照业务模块给拆分成了一个个私有仓库，这次的登录注册也是独立的一个&lt;code&gt;login&lt;/code&gt;仓库）&lt;/p&gt;
&lt;p&gt;然后，我们架构小哥“手贱”拉了&lt;code&gt;login&lt;/code&gt;仓库的代码，噩梦就开始了，每每他点击登录，拉起登录页的时候，就会&lt;code&gt;crash&lt;/code&gt;。我找到其他组热心的小哥，也拉了一下&lt;code&gt;login&lt;/code&gt;的代码，并不会复现（由于我上次要调试一台&lt;code&gt;iOS&lt;/code&gt; 11.3的ipX，&lt;code&gt;Xcode&lt;/code&gt;更新到了9.3.1，那位热心小哥是&lt;code&gt;Xcode&lt;/code&gt; 9.2.1，架构小哥后面也更新到9.3.1），说明我提交进仓库的代码并没有问题。&lt;br&gt;下面是异常信息：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Terminating app due to uncaught exception &amp;apos;NSUnknownKeyException&amp;apos;, reason: &amp;apos;[&amp;lt;**LoginViewController 0x************&amp;gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key **. &amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS调试" scheme="http://yoursite.com/categories/iOS%E8%B0%83%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>《Effective Objective-C 2.0 第二章》笔记</title>
    <link href="http://yoursite.com/2018/04/27/%E3%80%8AEffective-Objective-C-2-0-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/04/27/《Effective-Objective-C-2-0-第二章》笔记/</id>
    <published>2018-04-27T01:26:43.000Z</published>
    <updated>2018-05-14T02:24:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>6、理解“属性”这一概念<br>7、在对象内部尽量直接访问实例变量<br>8、理解“对象等同性”这一概念<br>9、以“类族模式”隐藏实现细节<br>10、在既有类中使用关联对象存放自定义数据<br>11、理解<code>objc_msgSend</code>的作用<br>12、理解消息转发机制<br>13、用“方法调配技术”调试“黑盒方法”<br>14、理解“类对象”的用意<br><a id="more"></a></p></blockquote><h2 id="6、理解“属性”这一概念"><a href="#6、理解“属性”这一概念" class="headerlink" title="6、理解“属性”这一概念"></a>6、理解“属性”这一概念</h2><blockquote><p>尽量不要直接访问实例变量，而应该通过存（<code>set</code>）取（<code>get</code>）方法来访问。OC语言中，提供了根据属性名来自动创建存取方法的机制，只要遵循正规的OC命名规范，就可以通过<code>@property</code>来实现，也就是我们所谓的“属性”的概念。<br>当你用如下方式声明一个类的实例变量之后，就可以使用<code>_name</code>和<code>self.name</code>来访问该属性的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    @interface EOCEmployer()</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line">@implementation EOCEmployer</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>其实是编译器在编译阶段就帮我们隐式创建了一个名为<code>_name</code>的实例变量和<code>self.name</code>的存取方法，等价于如下一段代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCEmployer()</span><br><span class="line">&#123;</span><br><span class="line">    NSString *_name;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation EOCEmployer</span><br><span class="line">@synthesize name = _name;</span><br><span class="line"></span><br><span class="line">- (NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    return _name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>由于<code>self.name</code>才会调用<code>name</code>属性的存取方法，所以，当你在重写它的存取方法之后，一定要记得调用<code>self.name</code>才会使代码生效。若你还想使用<code>_name</code>语法，那么一定要记得，在存取方法中，还需要修改<code>_name</code>的值。<br>例如，我想实现不论何时修改<code>EOCEmployer</code>对象的名字时，我都能知道，以便我在程序的任何地方及时响应这个变化，就可以这样改写一下它的<code>set</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)setName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;EOCEmployerNameWillChange&quot; object:nil];</span><br><span class="line">    _name = name;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;EOCEmployerNameDidChange&quot; object:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>但是为了让这个通知生效，那么，我们在修改<code>name</code>的时候，就不能通过<code>_name=@&quot;Yhaha&quot;</code>来做，而是应该调用<code>self.name=@&quot;Yhaha&quot;</code>。<br>当然，你如果不想用系统声明的<code>_name</code>变量名，也可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCEmployer()</span><br><span class="line">&#123;</span><br><span class="line">    NSString *_myName;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation EOCEmployer</span><br><span class="line">@synthesize name = _myName;</span><br><span class="line"></span><br><span class="line">- (NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    return _myName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;EOCEmployerNameWillChange&quot; object:nil];</span><br><span class="line">    _myName = name;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;EOCEmployerNameDidChange&quot; object:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>但是一般我们不推荐这么做，因为这样会降低你代码的可读性。<br>开发iOS程序时，应该使用<code>nonatomic</code>语义来声明属性，因为<code>atomic</code>语义声明的属性会影响性能，并且，<code>atomic</code>并不能保证属性操作的原子性。</p></blockquote><h2 id="7、在对象内部尽量直接访问实例变量"><a href="#7、在对象内部尽量直接访问实例变量" class="headerlink" title="7、在对象内部尽量直接访问实例变量"></a>7、在对象内部尽量直接访问实例变量</h2><blockquote><p>在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，则应通过属性来写。<br>在初始化方法及dealloc方法中，总是应该直接通过实例变量来读写数据。新建一个<code>EOCPerson</code>的子类——<code>EOCSmithPerson</code>，其<code>setLastName</code>修改的正是从父类继承的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;EOCPerson.h&quot;</span><br><span class="line">@interface EOCSmithPerson : EOCPerson</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;EOCSmithPerson.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation EOCSmithPerson</span><br><span class="line"></span><br><span class="line">- (void)setLastName:(NSString *)lastName</span><br><span class="line">&#123;</span><br><span class="line">    if(![lastName isEqualToString:@&quot;Smith&quot;]) &#123;</span><br><span class="line">        [NSException raise:NSInvalidArgumentException format:@&quot;Last name must be Smith&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    self.lastName = lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><blockquote><p>而在父类的初始化方法中，顺带给了对应属性以默认值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">//        NSLog(@&quot;%d&quot;, KK);</span><br><span class="line">        self.lastName = @&quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>则在创建子类对象的时候，会调用父类的初始化方法，从而抛出异常:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-05-14 09:57:42.298881+0800 OC[89129:14291062] *** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;Last name must be Smith&apos;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>在获取使用懒加载处理过的属性时，则最好都通过属性来读取数据，而不是访问实例变量。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;6、理解“属性”这一概念&lt;br&gt;7、在对象内部尽量直接访问实例变量&lt;br&gt;8、理解“对象等同性”这一概念&lt;br&gt;9、以“类族模式”隐藏实现细节&lt;br&gt;10、在既有类中使用关联对象存放自定义数据&lt;br&gt;11、理解&lt;code&gt;objc_msgSend&lt;/code&gt;的作用&lt;br&gt;12、理解消息转发机制&lt;br&gt;13、用“方法调配技术”调试“黑盒方法”&lt;br&gt;14、理解“类对象”的用意&lt;br&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://yoursite.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>《Effective Objective-C 2.0 第一章》笔记</title>
    <link href="http://yoursite.com/2018/04/19/%E3%80%8AEffective%20Objective-C%202.0%20%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/04/19/《Effective Objective-C 2.0 第一章》笔记/</id>
    <published>2018-04-19T03:22:35.000Z</published>
    <updated>2018-04-26T09:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《Effective Objective-C 2.0》一书列出了作者在平时开发和答疑过程中遇到的一些问题以及作者对OC语法上的风格提炼。对于不知道该如何培养出良好的编码风格的童鞋有非常好的指导作用，这篇笔记尽量把本书的例子，以简短易懂的方式抽象出来，并加上一些个人口语形式上的解读，方便理解。<br><a id="more"></a></p></blockquote><h2 id="1、了解OC语言的起源"><a href="#1、了解OC语言的起源" class="headerlink" title="1、了解OC语言的起源"></a>1、了解OC语言的起源</h2><blockquote><p>OC是一门采用“消息派发”而非“函数调用”机制的语言。</p><p>OC是C语言的超集，掌握C语言对理解和写出高效的OC代码有很大帮助。</p><p>OC对象都是分配在“堆区”而不是“栈区”，不能在“栈区”分配OC对象。</p><p>新建一个指向同一块地址的指针对象，不会拷贝原地址存放的对象。而该对象的指针地址被存放在“栈区”，“栈区”内存不需要手动管理，“堆区”内存需要直接（MRC）或间接（ARC）管理。</p><p><strong>如果只需要保存<code>int</code>、<code>float</code>、<code>double</code>等非对象类型，那么使用结构体而非OC对象可以减少开销。</strong></p></blockquote><h2 id="2、在类的头文件中尽量少引入其他头文件"><a href="#2、在类的头文件中尽量少引入其他头文件" class="headerlink" title="2、在类的头文件中尽量少引入其他头文件"></a>2、在类的头文件中尽量少引入其他头文件</h2><blockquote><p>当需要在类中引入其他类，仅作为类型声明时，可以不用引入头文件，而是采用<strong>前置声明</strong>的方式：<br><code>@class className</code><br>在需要使用引入类提供的对象和方法时，才需要引入它的头文件：<br>  <code>#import &quot;className.h&quot;</code></p><p><strong>将引入头文件的时机尽量延后，在确认有需要时再引入，可以减少使用一个类时所需要引入的头文件数量。引入过多不必要的头文件会增加代码编译的时间。</strong></p><p>前置声明可以解决两个类的互相引用问题，<strong>虽然使用#import 不会导致循环引用，但是会导致这两个类里面有一个无法被正确编译</strong>。<br><img src="https://s1.ax1x.com/2018/04/24/Cl1Azt.jpg" alt="EOCPerson" title="EOCPerson"> EOCPerson类<br><img src="https://s1.ax1x.com/2018/04/24/Cl1kRI.jpg" alt="" title="EOCEmployer"> EOCEmployer类</p><p>每次在头文件中，引入其他头文件之前，都需要问问自己，这样做有没有必要。可以使用前置声明，就不要引入新的头文件。若是必须要引入头文件，则尽量在<code>.m</code>文件中引入。<strong>这样做不仅可以缩短编译时间，还能降低彼此的依赖程度。</strong></p></blockquote><h2 id="3、多用字面量语法，少用与之等价的语法"><a href="#3、多用字面量语法，少用与之等价的语法" class="headerlink" title="3、多用字面量语法，少用与之等价的语法"></a>3、多用字面量语法，少用与之等价的语法</h2><blockquote><p><strong>使用字面量语法，可以使代码更简洁，例如：</strong><br>不用字面量语法初始化一个NSNumber对象:<br><code>NSNumber *aNumber = [NSNumber numberWithInt:1];</code><br>用字面量语法创建：<br><code>NSNumber *aNumber = @1; // 这样写过一次，你还会想用上面那样冗长的语法吗？</code><br>不仅仅是NSNumber，其他诸如字符串、数组、字典都可以采用字面量语法。<br>除了会使语法变得简洁，当你在初始化一个数组的时候，向字面量数组中插入一个为nil的对象，程序会抛出异常：<br><img src="https://s1.ax1x.com/2018/04/24/Cla7Xd.jpg" alt=""><br>若采用如下方式创建，则不会暴露问题（因为该方法会依次处理各个参数，直到有一个为nil为止，由于<code>bS</code>为<code>nil</code>，所以数组里面只有一个对象）：<br><img src="https://s1.ax1x.com/2018/04/24/ClaT6H.jpg" alt=""><br><strong> 由此可见，采用字面量的语法，可以在某些时候提前暴露出问题。</strong></p></blockquote><h2 id="4、多用类型常量，少用-define预处理指令"><a href="#4、多用类型常量，少用-define预处理指令" class="headerlink" title="4、多用类型常量，少用#define预处理指令"></a>4、多用类型常量，少用#define预处理指令</h2><blockquote><p>预处理（#define）定义的常量，类型不明确。而且定义出来的常量不含类型信息。即使有人重复定义了同名的常量值，编译器也不会报错，反而会使应用程序中的常量值无法确定。<br>如下，在两个头文件中用预处理语法定义两个同名常量：</p></blockquote><p> <img src="https://s1.ax1x.com/2018/04/25/Cl42FO.jpg" alt="EOCPerson头文件定义的常量"></p><p> <img src="https://s1.ax1x.com/2018/04/25/Cl46w6.jpg" alt="应用入口VC的头文件上定义的常量"></p><p> <img src="https://s1.ax1x.com/2018/04/25/Cl4cTK.jpg" alt="初始化EOCPerson的时候打印常量值"></p><p> <img src="https://s1.ax1x.com/2018/04/25/Cl4yex.jpg" alt=""></p><blockquote><p><strong>在最后打印出来的，是EOCPerson.h定义的那个常量的值（其实这也很好理解，由于编译的先后顺序，先编译的常量的值会被后编译同名常量的值覆盖）：</strong></p></blockquote><p> <img src="https://s1.ax1x.com/2018/04/25/Cl4rO1.jpg" alt="输出结果"></p><blockquote><p>在头文件用预处理方式定义常量，容易造成命名冲突。</p><p>大多数情况下，可以用下面这种方法来定义常量：<br><code>static const NSTimeInterval kAnimationDuration = 0.3;</code><br>而如果我们需要用上面这种方式来定义一个全局常量，可以这样做：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// EOCAnimatedView.h</span><br><span class="line">extern const NSTimeInterval EOCAnimatedViewAnimationDuration;</span><br><span class="line">// EOCAnimatedView.m</span><br><span class="line">const NSTimeInterval EOCAnimatedViewAnimationDuration = 0.3;</span><br></pre></td></tr></table></figure><blockquote><p><strong>不难发现，我们在命名这个常量的时候，是以类名作为前缀的，以保证常量名称的唯一性，从而避免命名冲突；</strong></p></blockquote><h2 id="5、用枚举表示状态、选项、状态码"><a href="#5、用枚举表示状态、选项、状态码" class="headerlink" title="5、用枚举表示状态、选项、状态码"></a>5、用枚举表示状态、选项、状态码</h2><blockquote><p>应该用枚举表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个通俗易懂的名字。<br>在定义一些选项的时候，特别是多选值，当要判断某个选项是否选中时，可以采用这种方式定义枚举（下面是一个系统UI框架定义的一个枚举值，用来表示某个视图应该如何在水平或者垂直方向上调整大小）：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) &#123;</span><br><span class="line">UIViewAutoresizingNone                 = 0,</span><br><span class="line">UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,</span><br><span class="line">UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,</span><br><span class="line">UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,</span><br><span class="line">UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,</span><br><span class="line">UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,</span><br><span class="line">UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>若当前已开启两个选项，要判断是否开启了<code>UIViewAutoresizingFlexibleWidth</code>这个选项，只需要如下操作：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum UIViewAutoresizing resizing = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;</span><br><span class="line">if(resizing &amp; UIViewAutoresizingFlexibleWidth) &#123;</span><br><span class="line">        // 为true则表示开启了UIViewAutoresizingFlexibleWidth选项</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在UIKit框架中还有一个例子，用枚举值告诉系统，当前视图所支持的显示方向：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)supportedInterfaceOrientations &#123;</span><br><span class="line">        return UIInterfaceOrientationPortrait | UIInterfaceOrientationLandscapeLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Foundation框架定义了一些辅助的宏，用这些宏来定义枚举类型时，也可以指定用于保存枚举值的底层数据类型。这些宏具备向后兼容能力，如果目标平台的编译器支持新标准，那就会选用新式语法，否则会采用旧语法:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, MyOptions) &#123;</span><br><span class="line">      MyOptionsValueA = 1 &lt;&lt; 0,</span><br><span class="line">      MyOptionsValueB = 1 &lt;&lt; 1,</span><br><span class="line">      MyOptionsValueC = 1 &lt;&lt; 2,</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  typedef NS_ENUM(NSUInteger, MyEnum) &#123;</span><br><span class="line">      MyEnumValueA,</span><br><span class="line">      MyEnumValueB,</span><br><span class="line">      MyEnumValueC,</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在<code>switch</code>语句中，如果使用枚举值作为分支判断依据，建议不要实现<code>default</code>分支，最好让<code>switch</code>能处理所有的分支。如果实现了<code>default</code>分支，当你添加新的枚举值时，很有可能会遗漏某些需要处理的分支，因为编译器不会提示你。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;《Effective Objective-C 2.0》一书列出了作者在平时开发和答疑过程中遇到的一些问题以及作者对OC语法上的风格提炼。对于不知道该如何培养出良好的编码风格的童鞋有非常好的指导作用，这篇笔记尽量把本书的例子，以简短易懂的方式抽象出来，并加上一些个人口语形式上的解读，方便理解。&lt;br&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://yoursite.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>写在“新”的一年</title>
    <link href="http://yoursite.com/2018/04/02/start/"/>
    <id>http://yoursite.com/2018/04/02/start/</id>
    <published>2018-04-02T09:26:00.000Z</published>
    <updated>2018-04-08T02:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>自从上回简书#饱醉豚事件把之前发布在简书上的文章撤下之后，有很长一段时间没有写过技术有关的文章了。加之，最近这段时间，公司开始要求加班，想着，刚好用加班的时间来学点什么吧。于是临时搭了个blog，就辟为自己平时技术分享和生活感悟的一个平台吧。</p></blockquote><a id="more"></a><h2 id="回首2017年"><a href="#回首2017年" class="headerlink" title="回首2017年"></a>回首2017年</h2><p>于2017年入职现在的公司，刚好是我毕业后整一年的时间点，也是来南京的第五个年头，这一年相对实习那段时间，好歹算稳定的吧。要说最大的收获，当然是结识了我可爱的小姐姐，收获了渴望已久的爱情啦。</p><h2 id="2018年想做的事"><a href="#2018年想做的事" class="headerlink" title="2018年想做的事"></a>2018年想做的事</h2><p>2018年，意味着我正式从事研发工作要满2年了，这也是一个程序员职业生涯中非常关键的节点。前两年的自己，技术栈可能还是仅仅停留在自己平时的业务层面上，对于未来的技术方向都是迷茫的：<em><strong>是该继续深挖iOS，往架构，逆向等方向深入，还是要去接触前端，慢慢往后端推进，往全栈方向发展。</strong></em></p><p><strong>最后列了一下2018年接下来的时间里需要深入了解的一些技术点和知识储备。</strong></p><p><strong>iOS方面：</strong></p><ol><li>深入阅读两个热门的开源库源码：<em><code>AFNetworking</code></em>、<em><code>SDWebimage</code></em>；</li><li>iOS技术栈方向： <code>Jerkins</code><strong>持续集成和自动化工具</strong>、<code>iOS</code><strong>响应式框架</strong><code>RAC</code>/<code>RxSwift</code></li><li>iOS基础知识：<strong>多线程操作</strong>、<strong>iOS常用网络协议</strong>（<code>http/https/socket/WebSocket/TCP/IP）</code>、<strong>内存/性能相关</strong>、<strong>渲染</strong><code>（CoreText/CoreGraphics/CoreAnimation）</code></li><li>脚本语言：<code>Ruby</code>/<code>Python</code></li></ol><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>最近会把之前的文章挑几篇出来整理一下，然后重新排版发布，充充门面，统一时间戳为2018-4-1——一个比较有个性的日子。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;自从上回简书#饱醉豚事件把之前发布在简书上的文章撤下之后，有很长一段时间没有写过技术有关的文章了。加之，最近这段时间，公司开始要求加班，想着，刚好用加班的时间来学点什么吧。于是临时搭了个blog，就辟为自己平时技术分享和生活感悟的一个平台吧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="生活感悟" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>CoreMotion计算设备yaw方向的旋转角度</title>
    <link href="http://yoursite.com/2018/04/01/CoreMotion/"/>
    <id>http://yoursite.com/2018/04/01/CoreMotion/</id>
    <published>2018-03-31T16:00:00.000Z</published>
    <updated>2018-04-04T09:39:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>先说说公司需求吧，这个需求里面有一个部分要做一个雷达，这个雷达要监听我的设备沿y轴旋转<strong>（为啥是y轴下面会提到）</strong>的倾角，然后根据这个倾角，雷达可以判断当前位置的物体是否在我的镜头范围内。</p></blockquote><a id="more"></a><h2 id="先挖一个坑"><a href="#先挖一个坑" class="headerlink" title="先挖一个坑"></a>先挖一个坑</h2><p>关于陀螺仪的创建和用法我这里按下不提，因为遇到这个问题的小伙伴对于获取<code>CMDeviceMotion</code>对象应该没什么问题。（<strong>啥，你说有？那就出门百度陀螺仪用法或者参考我后面给出的<a href="https://github.com/lgb1234a/TNMapARDemo" target="_blank" rel="noopener">demo</a></strong>）</p><p><strong>下面是第一个需要注意的地方：</strong>系统提供的<code>block</code>是在一个异步线程，所以如果需要做UI操作，请回到主线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Push方式获取和处理数据</span><br><span class="line">__weak typeof(self) weafSelf = self;</span><br><span class="line">[self.motionManager startDeviceMotionUpdatesToQueue:queue withHandler:^(CMDeviceMotion * _Nullable motion, NSError * _Nullable error) &#123;</span><br><span class="line">    // 首先这里是在一个异步线程，要刷新UI操作的话，需要回到主线程。</span><br><span class="line">    [weafSelf updateRadarStatuWithDeviceMotion:motion];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>现在，拿到了我们要的<code>CMDeviceMotion</code>对象，要获取旋转角度，自然要找到我们需要的那个参数，先请看下图（<a href="http://blog.denivip.ru/index.php/2013/07/the-art-of-core-motion-in-ios/?lang=en" target="_blank" rel="noopener">图片来源，有精力的同学可以看看这篇文章，里面非常系统的解释了CoreMotion里面一些现象的成因，有些坑我也是在这里找到解决方案的</a>）：</p><p><img src="http://upload-images.jianshu.io/upload_images/1445324-61b222ffc7193549.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="CoreMotionRotationAxes.png"></p><p>现在知道了我们需要获取y轴旋转角度的原因<strong>（x轴，z轴同理，就没必要一一介绍了）</strong>，我把关于设备当前放置状态的代码直接挑出来了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//4 代码来自上面我希望大家去看的那篇文章</span><br><span class="line">CMAttitude *attitude = self.motionManager.deviceMotion.attitude;</span><br><span class="line">self.pitch.text = [NSString stringWithFormat:@&quot;%.3f&quot;, attitude.pitch];</span><br><span class="line">self.roll.text = [NSString stringWithFormat:@&quot;%.3f&quot;, attitude.roll];</span><br><span class="line">self.yaw.text = [NSString stringWithFormat:@&quot;%.3f&quot;, attitude.yaw];</span><br></pre></td></tr></table></figure><p>其中<code>yaw</code>就是设备绕y轴的偏转角度，当时满心欢喜拿这个数据去旋转雷达中的镜头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// yaw角度为零的时候，就是出生点位置（注意这一块代码需要放在主线程中操作，参考[demo](https://github.com/lgb1234a/TNMapARDemo)）</span><br><span class="line">self.radarBackImgView.layer.anchorPoint = CGPointMake(0.5, 0.5);</span><br><span class="line">self.radarBackImgView.transform = CGAffineTransformMakeRotation(yaw);</span><br></pre></td></tr></table></figure><p>这样做，乍一看确实实现了我的需求，雷达中显示的镜头确实和我设备旋转是同步的，<strong>但是呢，看下面动图：</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/1445324-4005cd4b9a18b617.gif?imageMogr2/auto-orient/strip" alt="大辉哥强势出镜😂.gif"></p><p><strong>我现在将设备上下旋转，注意看右上角的雷达，居然也会出现旋转的情况，这说明yaw这个值会被roll和pitch影响，原文说明：</strong></p><p><code>At the first glance, nothing is complex here. All the angles duly change their value at device rotation. However, if we look closer, we can see that yaw can sometimes flip by somewhat 180 degrees at other angles’ change. So it means that changes in roll and pitch can affect yaw.</code></p><p><code>This post provides details of the issue called gimbal lock, along with its effect on Euler angles. The author also has mentioned the 180 degrees flip which you surely would like to avoid if animation of any on-screen objects depends on yaw.</code></p><p>对，你遇到了著名的<strong>万向节死锁问题</strong>，惊不惊喜，意不意外？所以作者特意告知大家，<strong>不要依赖yaw这个属性去做任何屏幕上控件的动画。</strong></p><p>好了，坑貌似已经说得很明确了，如果还觉得云里雾里的，强烈建议去看我上面说的那篇<a href="http://blog.denivip.ru/index.php/2013/07/the-art-of-core-motion-in-ios/?lang=en" target="_blank" rel="noopener">原文</a>，作者说的非常详细！！</p><h2 id="那我们该怎么办呢？？"><a href="#那我们该怎么办呢？？" class="headerlink" title="那我们该怎么办呢？？"></a>那我们该怎么办呢？？</h2><p>再来看看那篇文章里面还说了什么（膜拜作者大大）：</p><p><code>The post also mentions that a common way to avoid gimbal lock is to avoid Euler angles in favor of other ways of describing spacial orientation. Particularly, you can use quaternions.</code></p><p><strong>作者说，为了避免万向节死锁问题</strong>（说术语的感觉好爽啊，以后可以出去吹比了：你知道啥叫万向节死锁吗？咳~正经点！）<strong>，就不要用这个系统直接返回给你的欧拉角度</strong>（哎，太廉价的东西就是不好用），<strong>那我们用啥啊？贴心的作者说了，你可以用<code>quaternions</code></strong>（这玩意逼格更高，不信你去维基百科搜<code>四元数</code>，鉴于我现在没空深挖理论，<em>也挖不动</em>😂）。</p><p>现在知道了要用<strong>四元数</strong>去做，可是作者你没说完啊，我只知道要用它，但是还无从下手~</p><p><img src="http://upload-images.jianshu.io/upload_images/1445324-8fb8b6402c01223e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="CMAttitude的属性.png"></p><p>最后只能求助于万能的gg：</p><p><img src="http://upload-images.jianshu.io/upload_images/1445324-a182333fe5098540.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="搜索项.png"></p><p>嗯，结果有非常多，看来踩坑的人不少，各路算法简直琳琅满目，我就不给大家一一甄别了，直接上我找到的最满意的算法，完美解决了我现在遇到的问题，<a href="https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles" target="_blank" rel="noopener">维基百科-《Conversion between quaternions and Euler angles》</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void toEulerianAngle(const Quaterniond&amp; q, double&amp; roll, double&amp; pitch, double&amp; yaw)</span><br><span class="line">&#123;</span><br><span class="line">double ysqr = q.y() * q.y();</span><br><span class="line"></span><br><span class="line">// roll (x-axis rotation)</span><br><span class="line">double t0 = +2.0 * (q.w() * q.x() + q.y() * q.z());</span><br><span class="line">double t1 = +1.0 - 2.0 * (q.x() * q.x() + ysqr);</span><br><span class="line">roll = std::atan2(t0, t1);</span><br><span class="line"></span><br><span class="line">// pitch (y-axis rotation)</span><br><span class="line">double t2 = +2.0 * (q.w() * q.y() - q.z() * q.x());</span><br><span class="line">t2 = ((t2 &gt; 1.0) ? 1.0 : t2);</span><br><span class="line">t2 = ((t2 &lt; -1.0) ? -1.0 : t2);</span><br><span class="line">pitch = std::asin(t2);</span><br><span class="line"></span><br><span class="line">// yaw (z-axis rotation)</span><br><span class="line">double t3 = +2.0 * (q.w() * q.z() + q.x() * q.y());</span><br><span class="line">double t4 = +1.0 - 2.0 * (ysqr + q.z() * q.z());</span><br><span class="line">yaw = std::atan2(t3, t4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，这是个C++的算法（废话！），然后各位可以按照自己的需求，套用一下，至少对我的业务来说，是完全OK的~</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;先说说公司需求吧，这个需求里面有一个部分要做一个雷达，这个雷达要监听我的设备沿y轴旋转&lt;strong&gt;（为啥是y轴下面会提到）&lt;/strong&gt;的倾角，然后根据这个倾角，雷达可以判断当前位置的物体是否在我的镜头范围内。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://yoursite.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Xcode8频繁crash，且crash位置随机，无崩溃原因</title>
    <link href="http://yoursite.com/2018/04/01/Xcode-8%E5%9C%A8iOS9-3%E4%B9%8B%E5%89%8D%E7%9A%84%E8%AE%BE%E5%A4%87%EF%BC%88%E7%9C%9F%E6%9C%BA%E6%88%96%E6%A8%A1%E6%8B%9F%E5%99%A8%EF%BC%89%E4%B8%8A%E8%B0%83%E8%AF%95%EF%BC%8C%E9%A2%91%E7%B9%81crash%EF%BC%8Ccrash%E4%BD%8D%E7%BD%AE%E9%9A%8F%E6%9C%BA%EF%BC%8C%E4%B8%94%E6%97%A0%E5%B4%A9%E6%BA%83%E5%8E%9F%E5%9B%A0%20/"/>
    <id>http://yoursite.com/2018/04/01/Xcode-8在iOS9-3之前的设备（真机或模拟器）上调试，频繁crash，crash位置随机，且无崩溃原因 /</id>
    <published>2018-03-31T16:00:00.000Z</published>
    <updated>2018-04-04T09:40:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这次，对公司的线上项目进行一次小的升级，主要是针对iOS10的一些适配和之前存在的小问题进行修复。却在测试阶段出现了各种闪退，其中有：EXC_BAD_ACCESS, SIGNAL SIGABRT,且crash位置各异，并且只在iOS9.3以下闪退（此处可能不严谨，测试机只有iOS8.4以及iOS9.X、iOS10），而且Xcode 7在任何版本iOS都不闪退。</p></blockquote><a id="more"></a><h3 id="苦逼的调试过程"><a href="#苦逼的调试过程" class="headerlink" title="苦逼的调试过程"></a>苦逼的调试过程</h3><p>刚开始会在启动过程中频繁闪退，是由于苹果那边注册APNs频繁失败，导致JPush频繁占用主线程去重复注册，启动时间过长，然后进程被杀掉所导致的。</p><p>接下来也是按照原有的思路去调试，设置僵尸对象、检查内存泄漏，由于我们的项目是基于RectNative框架下开发的，JS端也是我怀疑的重点。但是由于根本无法获取的崩溃的log，并且每次崩溃都不是说集中在某个位置，Xcode 7不会崩溃，iOS9以上也不会崩溃。所以我感觉不是代码问题，而是Xcode 8引发的，就把调试思路换到Xcode 8的新特性上面。是不是我少了什么配置信息？</p><p>但是我之前出的项目，也是用的Xcode 8，但并不会出现这样的问题，所以肯定是我所不知道的原因导致的。</p><h3 id="苦逼的Google之旅"><a href="#苦逼的Google之旅" class="headerlink" title="苦逼的Google之旅"></a>苦逼的Google之旅</h3><p>由于墙内的关于Xcode8 以及iOS 10的相关信息实在是太少，还是选择了GG。</p><p><img src="http://upload-images.jianshu.io/upload_images/1445324-bca1ac7e774a1675.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20160926-0@2x.png"></p><p>看到这个random的时候，感觉看到了一丝曙光，进去一看<a href="https://openradar.appspot.com/28371396" target="_blank" rel="noopener">一个传送门</a>，更加坚信了我的判断，以及<a href="https://forums.developer.apple.com/thread/60919" target="_blank" rel="noopener">苹果开发者关于此类问题的描述</a>。</p><p>大意就是：你的项目中如果包含了16位或者是支持P3宽色域的image asset，那么请将项目运行在iOS9.3以上（原文为“以下”，感觉可能是笔误）。对于那些对图像要求并不高的项目，又希望兼容老的版本的设备，那么请将16位图换成8位的图。</p><h3 id="试试这根找到的救命稻草"><a href="#试试这根找到的救命稻草" class="headerlink" title="试试这根找到的救命稻草"></a>试试这根找到的救命稻草</h3><p>文中给出了详细的操作步骤来找到需要替换的图片：</p><ol><li>先把你的项目打出一个.ipa的包(如果你没有开发者证书，那么，请试试<a href="http://stackoverflow.com/questions/39404285/xcode-8-build-crash-on-ios-9-2-and-below" target="_blank" rel="noopener">第二个answer的脚本，未亲测，不保证有效哦~</a>)；</li><li>.ipa改成.zip格式；</li><li>解压缩之后会有一个名为“Payload folder”的文件夹，里面有一个.app；</li><li><p>打开终端，将当前工作路径改为“.app”之下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd path/to/Payload/your.app</span><br></pre></td></tr></table></figure></li><li><p>看看你的.app是否包含了一个“Assets.car”的文件，里面就可能有导致你程序崩溃的罪魁祸首；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 查看路径下所有文件，当然在文件灰常多的情况下，可以用find命令</span><br><span class="line">$ ls</span><br><span class="line">//抑或</span><br><span class="line">$ find . -name Assets.car</span><br></pre></td></tr></table></figure></li><li><p>要找出里面的16位图或者支持P3的image asset，现将这个文件用下面命令转成JSon格式：<strong>(/tmp/Assets.json为转出后的文件路径，可直接打开finder, cmd-shift-G，复制粘贴即可定位到)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo xcrun --sdk iphoneos assetutil --info Assets.car &gt; /tmp/Assets.json</span><br></pre></td></tr></table></figure></li><li><p>然后打开这个JSon文件，找出含有<code>&quot;DisplayGamut&quot;: &quot;P3&quot;</code> 配置的那个区块，对应<code>Name</code>这个Key的值就是这张图片的名字，如下图：</p></li></ol><p><img src="http://upload-images.jianshu.io/upload_images/1445324-6746e0c5311850ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2A9766A3-526D-4D70-898F-D68423305B3A.png"></p><p>8.在你的工程中找到叫这个名字的图片，然后重新做成8-bit的图片，替换原来的16-bit的图，重新run一下你的项目，就OK了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这次，对公司的线上项目进行一次小的升级，主要是针对iOS10的一些适配和之前存在的小问题进行修复。却在测试阶段出现了各种闪退，其中有：EXC_BAD_ACCESS, SIGNAL SIGABRT,且crash位置各异，并且只在iOS9.3以下闪退（此处可能不严谨，测试机只有iOS8.4以及iOS9.X、iOS10），而且Xcode 7在任何版本iOS都不闪退。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://yoursite.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>swift密文输入UITextfield内存问题</title>
    <link href="http://yoursite.com/2018/04/01/swift%E5%AF%86%E6%96%87%E8%BE%93%E5%85%A5UITextfield%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/04/01/swift密文输入UITextfield内存问题/</id>
    <published>2018-03-31T16:00:00.000Z</published>
    <updated>2018-04-04T09:40:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天帮基友看一个问题，一个注册页面，密码框输入到一定字符数量后内存就暴增，而用户名输入框却不会有这个问题，一开始以为是他用的第三方控件的问题，后来改成原生的UITextfield，还是会有这个问题，故排除之。</p></blockquote><a id="more"></a><h3 id="带着好奇心google了一下"><a href="#带着好奇心google了一下" class="headerlink" title="带着好奇心google了一下"></a>带着好奇心google了一下</h3><p><img src="http://upload-images.jianshu.io/upload_images/1445324-48d6dd4e3bea39a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-12-05 下午4.50.05.png"></p><p>找到如下一个描述，关于密文输入下会内存泄漏的问题，刚好符合现在的情况（用户名输入框不会引起内存泄漏，而密码输入框会这样）。一个<a href="https://forums.developer.apple.com/thread/66923" target="_blank" rel="noopener">不稳定的传送门</a>。<br><img src="http://upload-images.jianshu.io/upload_images/1445324-ea429eb10260f20e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="搜索结果"></p><p>原话：<br><em>I found the issue it was the font size of my text. For some reason if the font size is 20 and secure text is enabled when you reach 14 characters the app freezes. Can someone explain why this is happening or is it just an iOS bug that needs to be fixed.</em><br>某些情况下，如果你的字体大小达到了20，并且打开了密文输入，当你输入字符数达到14个的时候，app会卡死（模拟器下），真机下应该会崩溃。</p><h3 id="来看看有哪些情况"><a href="#来看看有哪些情况" class="headerlink" title="来看看有哪些情况"></a>来看看有哪些情况</h3><p>新建了一个只有一个UITextfield的应用：</p><p><strong>1. font:20,Min Font Size:19</strong>，崩溃</p><p><img src="http://upload-images.jianshu.io/upload_images/1445324-5faf08055085f8ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="参数"></p><p>当我输入到第十五个字符的时候，内存开始无限制增长：</p><p><img src="http://upload-images.jianshu.io/upload_images/1445324-542b08c0b0687cb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-12-05 下午4.58.41.png"></p><p><strong>2. font:19,Min Font Size:19</strong>，不会崩溃</p><p><img src="http://upload-images.jianshu.io/upload_images/1445324-36425e8b721aa03f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="只修改Font为19"></p><p><strong>3. font:19,Min Font Size:20</strong>，不会崩溃</p><p><img src="http://upload-images.jianshu.io/upload_images/1445324-c498dbfd5166806e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Min Font Size改为20"></p><p><strong>4. font:20,Min Font Size:20</strong>，不会崩溃</p><p><img src="http://upload-images.jianshu.io/upload_images/1445324-847e440d58895503.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="都改为20"></p><p><strong>5. 在第一种情况下勾除Adjust to Fit</strong>，不会崩溃</p><p><img src="http://upload-images.jianshu.io/upload_images/1445324-a8c6fbd781c0e3c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="勾除Adjust to Fit"></p><h3 id="排除那哥们思路进行的测试"><a href="#排除那哥们思路进行的测试" class="headerlink" title="排除那哥们思路进行的测试"></a>排除那哥们思路进行的测试</h3><p><strong>两个都低于20，但是Font比Min Font Size大</strong>，崩溃</p><p><img src="http://upload-images.jianshu.io/upload_images/1445324-77b6cd4861cb70d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="崩溃"></p><p>其实这个并没有临界值，原因呢？如下面这个，不会崩溃。</p><p><img src="http://upload-images.jianshu.io/upload_images/1445324-1d8fd9ccd8d96a25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不会崩溃"></p><p>但是<strong>只要Font比Min Font Size大，并且Min Font Size越小，就越不容易崩溃。如果要达到会崩溃的地步，就需要两者的差值越大越容易崩溃。</strong>如下面这个：</p><p><img src="http://upload-images.jianshu.io/upload_images/1445324-7fe3a834a2dbcd88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="成功崩溃"></p><h3 id="最后说几句废话"><a href="#最后说几句废话" class="headerlink" title="最后说几句废话"></a>最后说几句废话</h3><p>这是自己在swift下做的简单测试，从现象来看，应该是官方的bug，期待日后会fix掉。</p><p><em>如果有不正确的地方，欢迎指正！</em></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天帮基友看一个问题，一个注册页面，密码框输入到一定字符数量后内存就暴增，而用户名输入框却不会有这个问题，一开始以为是他用的第三方控件的问题，后来改成原生的UITextfield，还是会有这个问题，故排除之。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://yoursite.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
</feed>
